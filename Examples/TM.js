/* eslint-disable unicorn/filename-case */
/* eslint-disable unicorn/no-array-callback-reference */
/* eslint-disable unicorn/prefer-number-properties */
/* eslint-disable unicorn/prevent-abbreviations */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable jsdoc/require-param */
/* eslint-disable jsdoc/require-returns */

/*
 * IMPORTANT DO NOT EDIT THIS FILE IN VS Code App
 * Edit in the Earth Engine code environment.
 * Pull this file from Earth Engine repo users/ngis-ee/tracemark
 * Then run getlib.sh or equivalent to convert to convert ES5 to ES6.
 * getlib.sh will also uncomment the line below (removes the leading slashes)
 */
// import * as ee from '@google/earthengine';

/**
 * Earth Engine reusable library for TRACEMARK
 * 
 * This library provides the key Earth Engine functionality through a
 * number of publically exported functions.
 *
 * NOTE - this library is written in the ideal format 
 * for EO <> NGIS engineering handover. The important
 * sections are described below;r
 * 
 * - constants should be defined as a dictionary at the top of the 
 * script. Engineering will wrap this in a function called getConstants()
 * in order to avoid race conditions in the nodejs app.
 * 
 * - exported (i.e. public functions) need to be defined first. 
 * Use the "patching" syntax of attaching each public function 
 * to a new named property on the `exports` object.
 * 
 * - private helper functions must be defined last
 * 
 * - use the JSDOC syntax and ensure all public functions.
 * have been documented. comments on private functions are 
 * encouraged but aren't required, especially for simple functions.
 * 
 * - ensure no errors/warnings/info suggestions. while these 
 * still allow the script to compile but they break the CI 
 * build pipelines in the dashboard with linting errors.
 * 
 */

/**
 * Asset paths globally available to the user / service account
 */
exports.CONSTANTS = {
  GAUL_SIMPLIFIED_500m_L1: 'FAO/GAUL_SIMPLIFIED_500m/2015/level1',
  GAUL_SIMPLIFIED_500m_L2: 'FAO/GAUL_SIMPLIFIED_500m/2015/level2',
  NICFI_AFRICA: 'projects/planet-nicfi/assets/basemaps/africa',
  NICFI_AMERICAS: 'projects/planet-nicfi/assets/basemaps/americas',
  NICFI_ASIA: 'projects/planet-nicfi/assets/basemaps/asia',
  ALERTS_RADD: 'projects/radar-wur/raddalert/v1',
  DYNAMIC_WORLD: 'GOOGLE/DYNAMICWORLD/V1',
  DYNAMIC_WORLD_BANDS: ['water', 'trees', 'grass', 'flooded_vegetation', 'crops', 'shrub_and_scrub', 'built', 'bare', 'snow_and_ice'],
  ALERTS_GLAD: {
    latest: 'projects/glad/alert/UpdResult',
    a2020: 'projects/glad/alert/2020final',
    a2019: 'projects/glad/alert/2019final',
    a2018: 'projects/glad/alert/2018final',
    a2017: 'projects/glad/alert/2017final'
  },
  ALERTS_MODIS: 'MODIS/006/MCD64A1',
  ALERTS_FIRMS: 'FIRMS',
  ALERTS_HANSEN: 'UMD/hansen/global_forest_change_2021_v1_9',
  /** Contains a 'friction' band representing cost in minutes to travel through each pixel per https://code.earthengine.google.com/?asset=Oxford/MAP/friction_surface_2019 */
  FRICTION: 'Oxford/MAP/friction_surface_2019',
  MASKS_FOREST_ALOS: 'JAXA/ALOS/PALSAR/YEARLY/FNF',
  MASKS_FOREST_COPERNICUS_2015_2019: 'COPERNICUS/Landcover/100m/Proba-V-C3/Global',
  MASKS_FOREST_TROPICAL_2001: 'UMD/GLAD/PRIMARY_HUMID_TROPICAL_FORESTS/v1',
  MASKS_PALM_2019: 'BIOPAMA/GlobalOilPalm/v1',
  VEGETATION_HEIGHT_GEDI: 'LARSE/GEDI/GEDI02_A_002_MONTHLY',
  
  MS_PER_DAY: 1000 * 60 * 60 * 24, // 8.64e7
  PERCENT_TREE_COVERAGE_FOR_FOREST: 20, // applied to HANSEN https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2021_v1_9
}

/**
 * NGIS_ASSETS are defined as functions, in order to allow consumers of this library
 * to override the EE_PROJECT by calling NGIS_ASSETS.setProject(newProject)
 */
exports.NGIS_ASSETS = {
  EE_PROJECT: 'ngis-tracemark-core-dev',

  setProject: function(project) {
    exports.NGIS_ASSETS.EE_PROJECT = project;
  },

  getAssetPath: function() {
    return 'projects/' + exports.NGIS_ASSETS.EE_PROJECT + '/assets';
  },
  
  /** Palm mask ImageCollection for Indonesia and Malaysia from 2019 to 2021 */
  getPalmMaskNgis: function() {
    return exports.NGIS_ASSETS.getAssetPath() + '/masks/palm/Palm_NGIS';
  },
  
  getPeatMaskCifor2016: function() {
    return exports.NGIS_ASSETS.getAssetPath() + '/masks/peat/TROP-SUBTROP_PeatV21_2016_CIFOR';
  },
  
  getLandCoverBands: function() {
    return ['unidentified'].concat(exports.CONSTANTS.DYNAMIC_WORLD_BANDS).concat(['palm']);
  },
  
  getLandCoverVisualization: function() {
    return {
      'min': 1, // 0 is 'unidentified'
      'max': 10,
      'palette': ['419BDF', '397D49', '88B053', '7A87C6', 'E49635', 'DFC35A', 'C4281B', 'A59B8F', 'B39FE1', 'EE17C4']
    };
  }
}


// EXPORTED FUNCTIONS ----------------------------------------------------------------------------

// ADMINISTRATIVE BOUNDARIES ---------------------------------------------------------------------

/**
 * Get an ee.Image of the Provinces dataset
 */
exports.get_provinces = function() {
  var fc = ee.FeatureCollection(exports.CONSTANTS.GAUL_SIMPLIFIED_500m_L1);

  // Create an empty image into which to paint the features, cast to byte.
  var empty = ee.Image().byte();
  // Paint the interior of the polygons with different colors.
  var fills = empty.paint({
    featureCollection: fc,
    color: 'Shape_Area',
  });

  return fills;
}

/**
 * Get an ee.Image of the Districts dataset
 */
exports.get_districts = function() {
  var fc = ee.FeatureCollection(exports.CONSTANTS.GAUL_SIMPLIFIED_500m_L2);

  // Create an empty image into which to paint the features, cast to byte.
  var empty = ee.Image().byte();
  // Paint the interior of the polygons with different colors.
  var fills = empty.paint({
    featureCollection: fc,
    color: 'Shape_Area',
  });

  return fills;
}

// NICFI MOSAICS (HIGH-RES) ----------------------------------------------------------------------

/**
 * NICFI - High resolution image collection of tropical areas
 * https://developers.google.com/earth-engine/datasets/catalog/projects_planet-nicfi_assets_basemaps_africa
 * https://developers.google.com/earth-engine/datasets/catalog/projects_planet-nicfi_assets_basemaps_americas
 * https://developers.google.com/earth-engine/datasets/catalog/projects_planet-nicfi_assets_basemaps_asia
 */
exports.get_nicfi_collection = function(_startUnixDays, _endUnixDays) {
  // NICFI collection has images for the 1st day of each month.
  var africa = ee.ImageCollection(exports.CONSTANTS.NICFI_AFRICA);
  var americas = ee.ImageCollection(exports.CONSTANTS.NICFI_AMERICAS);
  var asia = ee.ImageCollection(exports.CONSTANTS.NICFI_ASIA);
  var nicfi = africa.merge(americas).merge(asia);
  if (_startUnixDays) {
    var startDate = ee.Date(unixDaysToEpochMs(_startUnixDays));
    if (_endUnixDays) {
      var endDate = ee.Date(unixDaysToEpochMs(_endUnixDays));
      return nicfi.filterDate(startDate, endDate);
    } else {
      return nicfi.filterDate(startDate);
    }
  }
  return nicfi;
}

/**
 * NICFI - High resolution mosaic of tropical forest areas
 * https://developers.google.com/earth-engine/datasets/catalog/projects_planet-nicfi_assets_basemaps_asia
 */
exports.get_nicfi_scene = function(unixDays) {
  // NICFI collection has images for the 1st day of each month.
  // E.g. to include imagery for any of October, the date parameter must be 1st of October
  // If start param is 2nd of October, then no imagery for October will be included
  var startOfMonth = ee.Date(unixDaysToEpochMs(unixDays)).update({ day: 1 });
  var startOfMonthUnixDays = startOfMonth.millis().divide(exports.CONSTANTS.MS_PER_DAY);
  return get_nicfi_collection(startOfMonthUnixDays).mosaic();
}

// LANDCOVER MASKS -------------------------------------------------------------------------------

// FOREST (Global), PEAT (currently sub tropics and tropics, 2016 only), PALM 2019+ mainly Indonesia & Malaysia

/**
 * Get primary tropical forests for 2001
 * return an ee.Image primary forest mask for the selected year with value of 1
 */
exports.getForestTropical = function() {
  return ee.ImageCollection(exports.CONSTANTS.MASKS_FOREST_TROPICAL_2001).mosaic().selfMask();
}

/**
 * Get yearly forest masks up to 2017 from ALOS
 * return an ee.Image forest mask for the selected year with value of 1
 * any year over 2017 will give you the 2017 mask
 */
exports.getForestALOS = function(year) {
  var y = ee.Algorithms.If(ee.Number(year).gt(2017), 2017, year);
  var forest = ee.ImageCollection(exports.CONSTANTS.MASKS_FOREST_ALOS)
                // .filter(ee.Filter.metadata('system:index', 'equals', ee.String(y)))
                .filter(ee.Filter.eq('system:index', ee.String(y)))
                .mosaic();
  return forest.updateMask(forest.lt(2)); 
}

/**
 * Get yearly forest masks from copernicus landcover
 * return an ee.Image forest mask for the selected year with value of 1
 * this collections has year 2015-2019
 * if year < 2015 it will return 2015 mask, if year > 2019 will return 2019 mask
 */
exports.getForestCopernicus = function(year) {
  var y = ee.Algorithms.If(ee.Number(year).lt(2015), 2015, ee.Algorithms.If(ee.Number(year).gt(2019), 2019, year));
  var landcover = ee.ImageCollection(exports.CONSTANTS.MASKS_FOREST_COPERNICUS_2015_2019)
                    // .filter(ee.Filter.metadata('system:index', 'equals', ee.String(y)))
                    .filter(ee.Filter.eq('system:index', ee.String(y)))
                    .mosaic();
  landcover = landcover.updateMask(landcover.gt(100));
  var forest = landcover.updateMask(landcover.lt(200));
  // return forest.remap({from: [0], to: [0], defaultValue: 1}).rename('forest');
  return forest.remap([0], [0], 1).rename('forest');
}

/**
 * Forest cut off (2015): Global Forest Mask where forest pixels from getForestCopernicus and ALOS forest mask overlap in 2015
 */
exports.forestMask2015_ALOS_COPERNICUS = function() {
 var ForestCopernicus_2015 = exports.getForestCopernicus(2015);
 var ForestALOS_2015 = exports.getForestALOS(2015);
 var forestMask_2015 = ForestCopernicus_2015.add(ForestALOS_2015).eq(2);
 return ee.Image(forestMask_2015).selfMask();
}

/**
 * Global forest cut off mask as at the end of 2015
 */
exports.forestMask2015 = function() {
  // return exports.forestMask2015_ALOS_COPERNICUS();
  return exports.hansenTreeMaskAtStartOf(2016);
}

/**
 * Global Forest Mask using HANSEN tree coverage since the start of 2001.
 * This is the result of removing all the deforestation pixels from the treecover2000 from Hansen data.
 * https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2021_v1_9
 *
 * @param {number} year - the year at which the returned forest image should be valid for January 1st
 * @param {number} _minimumTreeCoveragePercent - optional minimum percentage of tree coverage to qualify as "forest". If unspecified, default of CONSTANTS.PERCENT_TREE_COVERAGE_FOR_FOREST is used.
 * @returns {ee.Image} with a single 'treecover2000' band containing tree coverage percentage as at 2000,
 * with forest lost between 2001 and the requested year masked out.
 */
exports.hansenTreeMaskAtStartOf = function(year, _minimumTreeCoveragePercent) {
  var thisYear = new Date().getUTCFullYear();
  if (typeof year !== 'number' || isNaN(year) || year < 2001 || year > thisYear) {
    throw new Error(
      'hansenTreeMaskAtStartOf(year, _minimumTreeCoveragePercent) requires a year between 2001 and ' + thisYear.toString()
    );
  }
  if (
    _minimumTreeCoveragePercent &&
    (typeof _minimumTreeCoveragePercent !== 'number' ||
      isNaN(_minimumTreeCoveragePercent) ||
      _minimumTreeCoveragePercent < 0 ||
      _minimumTreeCoveragePercent > 100)
  ) {
    throw new Error('hansenTreeMaskAtStartOf(year, _minimumTreeCoveragePercent) requires a percent between 0 and 100');
  }
  
  // Get Hansen tree coverage over _minimumTreeCoveragePercent as at the end of 2000
  var hansen = ee.Image(exports.CONSTANTS.ALERTS_HANSEN);
  var treeCoverEnd2000 = hansen
        .select('treecover2000')
        .gte(_minimumTreeCoveragePercent || exports.CONSTANTS.PERCENT_TREE_COVERAGE_FOR_FOREST)
        .selfMask();
  if (year === 2001) {
    return treeCoverEnd2000;
  }
  
  var deforestationBetween2001AndYear = exports.get_hansen_alerts(2001, year - 1, false).selfMask();
  var noDeforestationBeforeYear = deforestationBetween2001AndYear.unmask().not();
  return treeCoverEnd2000.updateMask(noDeforestationBeforeYear);
}

/**
 * Peatland mask from CIFOR for tropical and sub tropical regions
 * this is a mask for just 2016
 * no yearly peat data is not avalible
 */
exports.peatlandMask = function() {
  var peat = ee.Image(exports.NGIS_ASSETS.getPeatMaskCifor2016());
  return peat.updateMask(peat.gt(0));
}

/**
 * Showing only forest for 2015 (no peat)
 */
exports.onlyForest2015 = function() {
  return exports.forestMask2015().unmask()
          .subtract(exports.peatlandMask().unmask())
          .eq(1).selfMask();
}

/**
 * Showing only peat for 2015 (no forest)
 */
exports.onlyPeat2015 = function() {
  return exports.forestMask2015().unmask()
          .subtract(exports.peatlandMask().unmask())
          .eq(-1).selfMask();
}  

/**
 * Showing overlapping peat - forest for 2015 
 */
exports.peatForestIntersectionAtStartOf2016 = function() {
  return exports.forestMask2015()
          .multiply(exports.peatlandMask().unmask())
          .eq(1).selfMask();
}

/**
 * Get the Descals (private) 2019 global palm mask
 * return an ee.Image palm mask with palm having a value of 1
 */
exports.getPalmMaskDescals = function() {
  var palm = ee.ImageCollection(exports.CONSTANTS.MASKS_PALM_2019)
              .select('classification')
              .mosaic();
  palm = palm.remap([1,2,3], [1,1,0]).rename('classification');
  return palm.updateMask(palm.gt(0));
}

/**
 * Get the NGIS palm mask as at the end of a specified year
 *
 * @returns {ee.Image} mask with values of 1 where palm was detected sometime during the specified year
 */
exports.getPalmMaskAtEndOf = function(year) {
  var lastYear = new Date().getUTCFullYear() - 1;
  if (typeof year !== 'number' || isNaN(year) || year < 2019 || year > lastYear) {
    throw new Error('getPalmMaskAtEndOf(year) requires a year between 2019 and ' + lastYear.toString());
  }

  var startUnixDays = exports.dateToUnixDays(year);
  var startDate = unixDaysToDate(startUnixDays);
  var endUnixDays = exports.dateToUnixDays(year + 1) - 1;
  var endDate = unixDaysToDate(endUnixDays);
  
  // Get 2019+ Indonesia and Malaysia palm mask imagery
  var palmMalaysiaForYear = ee.ImageCollection(exports.NGIS_ASSETS.getPalmMaskNgis())
                              .filterDate(startDate, endDate)
                              .mosaic();
  /* NOTE: Uncomment the below if we don't want to overlay the 2019 global mask with future years too..
  if (year > 2019) {
    return ee.Image(palmMalaysiaForYear.selfMask());
  }
  */
  
  // Get 2019 global palm mask
  var palmGlobal2019 = ee.ImageCollection(exports.CONSTANTS.MASKS_PALM_2019).mosaic().lt(3).selfMask();

  return palmMalaysiaForYear.unmask().or(palmGlobal2019.unmask()).selfMask();
}

/**
 * Get the NGIS palm mask as at the start of a specified year
 *
 * @returns {ee.Image} mask with values of 1 where palm was detected sometime during the _previous_ year
 */
exports.getPalmMaskAtStartOf = function(year) {
  return exports.getPalmMaskAtEndOf(year - 1);
}

// LANDCOVER MASK (ANNUAL) ------------------------------------------------------

/**
 * Gets a map showing land coverage types as detected during a specified year.
 * 
 * It primarily uses Dynamic World data, adding:
 * - Hansen tree coverage at the end of the year
 * - NGIS and BIOPAMA palm plantations at the end of the year from 2019 onwards
 * 
 * The function mosaics 16 months to try fill identification gaps over cloudy regions,
 * weighting probabilities of pixels from the last four months of the year the highest.
 */
exports.landCoverAtEndOf = function(year) {
  var lastYear = new Date().getUTCFullYear() - 1;
  if (typeof year !== 'number' || isNaN(year) || year < 2016 || year > lastYear) {
    throw new Error('landCoverAtEndOf(year) requires a year between 2016 and ' + lastYear.toString());
  }

  // Setup four mosaics spanning 4 months each, weighted according to how close to the end of the year they are
  var startOfYear = unixDaysToDate(exports.dateToUnixDays(year));
  var weights = [0.7, 1.0, 1.3, 1.0]; // weighted towards the third mosaic, which is the last one of 'year'
  var mosaics = [];
  function addDays(date, days) {
    var result = new Date(date);
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    result.setDate(result.getDate() + days);
    return result;
  }
  for (var i=0; i <= 3; i++) {
    var startDate = addDays(startOfYear, i * 122);
    var endDate = addDays(startDate, 122);
    var mosaic = ee.ImageCollection(exports.CONSTANTS.DYNAMIC_WORLD)
                  .filterDate(startDate, endDate)
                  .mosaic()
                  .select(exports.CONSTANTS.DYNAMIC_WORLD_BANDS)
                  .multiply(weights[i]);
    mosaics.push(mosaic);
  }

  // Aggregate pixel probabilities  
  var weightedMean = ee.ImageCollection(mosaics).mean();
  
  // Convert image bands representing landcover classes back to an ImageCollection, one image per band
  var landcoverCollection = ee.ImageCollection(
    exports.CONSTANTS.DYNAMIC_WORLD_BANDS.map(
      function(band) {
        return weightedMean
                  .select(band)
                  .rename('landcover')
                  .cast({'landcover': 'float'});
                  // .set('label', band);
      }
    ));

  // Build a single band image showing the maximum probability for each pixel (%)
  var max = landcoverCollection.max();
  
  // Helper to identify the class with the maximum probability for each pixel,
  // and reclassify the DWimage into categories showing the 'label' of the most likely class
  function combineDiff(img) {
    // Add 1 to the image index, to avoid NODATA for 'water' (0) pixels
    var landcoverNumber = ee.Number.parse(img.get('system:index')).add(1);
    // Return class number (1-9) of the most likely landcover type for each pixel
    return ee.Image(landcoverNumber)
             .updateMask(img.eq(max))
             .rename('landcover')
             .cast({'landcover': 'short'});
  }
  
  // Reduce the landcover ImageCollection
  var dwYear = landcoverCollection.map(combineDiff).mosaic();
  
  // Get palm if available
  var palm = year >= 2019 ? exports.getPalmMaskAtEndOf(year) : ee.Image(0);

  // Get Hansen (> 20%) trees as at end of the year
  var hansen = exports.hansenTreeMaskAtStartOf(year + 1);

  // Final reclassification
  return dwYear
    .where(hansen.gt(0), 2) // override DW where Hansen shows trees at the end of the year
    .where(palm.gt(0), 10)  // override both DW and Hansen where palm was seen during the year
    .selfMask();
    // .updateMask(exports.waterMask());
};

/**
 * For each incoming region, builds a feature with properties representing land coverage types
 * and their areas in square metres (where deemed dominant) as detected during a specified year.
 *
 * It primarily uses Dynamic World data which is available from 2016, adding:
 * - Hansen tree coverage at the end of the year
 * - NGIS and BIOPAMA palm plantations at the end of the year from 2019 onwards
 *
 * The function uses a percentile reducer to reduce DW noise produced by clouds, especially in tropical latitudes.
 *
 * @param {ee.Geometry | ee.Feature | ee.FeatureCollection} regions - multi/polygon(s) to calculate land cover stats for.
 * @param {number} _longitude - centroid longitude to project a sphere around, to improve area calculation accuracy.
 * @param {number} _startYear - optional start year between 2016 and last year.
 * @param {number} _endYear - optional end year between _startYear and last year.
 * @param {number} _scale - optional resolution in metres - default is 10 metres, the nominal scale for Dynamic World imagery.
 * @returns {ee.FeatureCollection} FeatureCollection containing one feature per input region.
 * Each has an area_m2 property, as well as year_class_name properties holding numeric square metre values:
 * - `area_m2`: total area in square metres
 * - `2016_unidentified`: area not identified due to lack of sufficient cloudless satellite coverage in 2016
 * - `2019_palm`: area intersecting our 2019 palm mask
 * - ...
 * - `2021_trees`: area identified as trees in the Dynamic World dataset, or from our Hansen tree mask as at the end of 2021
 * - `yyyy_class_name`: all other combinations for landcover classes as described at https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_DYNAMICWORLD_V1
 */
exports.annualLandCoverTable = function(regions, _longitude, _startYear, _endYear, _scale) {
  var lastYear = new Date().getUTCFullYear() - 1;
  if (typeof _startYear === 'number' && (isNaN(_startYear) || _startYear < 2016 || _startYear > lastYear)) {
    throw new Error('annualLandCoverTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _startYear is optional, but must be between 2016 and ' + lastYear.toString());
  }
  _startYear = _startYear || 2016;
  if (typeof _endYear === 'number' && (isNaN(_endYear) || _endYear < _startYear || _endYear > lastYear)) {
    throw new Error('annualLandCoverTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _endYear is optional, but must be between _startYear and ' + lastYear.toString());
  }
  _endYear = _endYear || lastYear;
  if (typeof _scale === 'number' && (isNaN(_scale) || _scale <= 0)) {
    throw new Error('annualLandCoverTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _scale is optional, but must be a positive number');
  }
  _scale = _scale || 10; // ee.ImageCollection(CONSTANTS.DYNAMIC_WORLD).first().projection().nominalScale()
    
  var regionFeatureCollection = ee.FeatureCollection(regions);
  var m2 = ee.Image.pixelArea();
  var classNames = exports.NGIS_ASSETS.getLandCoverBands();

  // For each year, mask m2 area based on landCover classification values, adding a band for each
  var yearlyImages = [];
  for (var year = +_startYear; year <= +_endYear; year++) {
    var landCover = exports.landCoverAtEndOf(year).unmask();
    var classAreas = ee.Image(0);
    for (var band = 0; band < classNames.length; band++) {
      var classMask = landCover.eq(band).selfMask();
      var classArea = m2.updateMask(classMask).rename(classNames[band]);
      classAreas = classAreas.addBands(classArea);
    }
    var yearImage = classAreas.select(classNames).set('system:index', ee.Number(year).format('%.0f'));
    yearlyImages.push(yearImage);
  }
  
  // Put yearly images into an image collection and reduce to a single image with bands year_className
  var yearClassBands = ee.ImageCollection(yearlyImages).toBands();
  var areaImage = m2.rename('area_m2').addBands(yearClassBands);
  
  // WKT for World Mollweide projection with central meridian centered on region of interest
  var wkt = exports.getCrsWorldMollweide(_longitude);

  return areaImage.reduceRegions({collection:regionFeatureCollection, reducer:ee.Reducer.sum(), scale:_scale, crs:wkt});
}

/**
 * For each incoming region, builds a feature with properties representing a land coverage type of 'trees' with area in
 * square metres as detected during a specified year. It uses Hansen tree coverage data which is available from 2000.
 *
 * @param {ee.Geometry | ee.Feature | ee.FeatureCollection} regions - multi/polygon(s) to calculate land cover stats for.
 * @param {number} _longitude - centroid longitude to project a sphere around, to improve area calculation accuracy.
 * @param {number} _startYear - optional start year between 2000 and last year.
 * @param {number} _endYear - optional end year between _startYear and last year.
 * @param {number} _scale - optional resolution in metres - default is 10 metres, the nominal scale for Hansen imagery.
 * @param {number} _minimumTreeCoveragePercent - optional minimum percentage of tree coverage to qualify as 'trees'. If unspecified, default of CONSTANTS.PERCENT_TREE_COVERAGE_FOR_FOREST is used.
 * @returns {ee.FeatureCollection} FeatureCollection containing one feature per input region.
 * Each has an area_m2 property, as well as year_class_name properties holding numeric square metre values:
 * - `area_m2`: total area in square metres
 * - `2000_trees`: area identified as trees at the end of 2000 using the Hansen dataset
 * - `2001_trees`: `2000_trees` minus area detected with 'loss' during 2001
 * - ...
 * - `2021_trees`: `2000_trees` minus area detected with 'loss' during 2001-2021
 */
exports.hansenTreesTable = function(regions, _longitude, _startYear, _endYear, _scale, _minimumTreeCoveragePercent) {
  var lastYear = new Date().getUTCFullYear() - 1;
  if (typeof _startYear === 'number' && (isNaN(_startYear) || _startYear < 2000 || _startYear > lastYear)) {
    throw new Error('hansenTreesTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _startYear is optional, but must be between 2000 and ' + lastYear.toString());
  }
  _startYear = _startYear || 2000;
  if (typeof _endYear === 'number' && (isNaN(_endYear) || _endYear < _startYear || _endYear > lastYear)) {
    throw new Error('hansenTreesTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _endYear is optional, but must be between _startYear and ' + lastYear.toString());
  }
  _endYear = _endYear || lastYear;
  if (typeof _scale === 'number' && (isNaN(_scale) || _scale <= 0)) {
    throw new Error('hansenTreesTable(areas, _longitude?, _startYear?, _endYear?, _scale?) _scale is optional, but must be a positive number');
  }
  _scale = _scale || 10; // ee.ImageCollection(CONSTANTS.DYNAMIC_WORLD).first().projection().nominalScale()
    
  var regionFeatureCollection = ee.FeatureCollection(regions);
  var m2 = ee.Image.pixelArea();

  // For each year, mask m2 area based on 'trees'
  var yearlyImages = [];
  for (var year = +_startYear; year <= +_endYear; year++) {
    var treeMask = exports.hansenTreeMaskAtStartOf(year + 1);
    var treeArea = m2.updateMask(treeMask).rename('trees');
    var yearImage = treeArea.set('system:index', ee.Number(year).format('%.0f'));
    yearlyImages.push(yearImage);
  }
  
  // Put yearly images into an image collection and reduce to a single image with bands year_className
  var yearClassBands = ee.ImageCollection(yearlyImages).toBands();
  var areaImage = m2.rename('area_m2').addBands(yearClassBands);
  
  // WKT for World Mollweide projection with central meridian centered on region of interest
  var wkt = exports.getCrsWorldMollweide(_longitude);

  return areaImage.reduceRegions({collection:regionFeatureCollection, reducer:ee.Reducer.sum(), scale:_scale, crs:wkt});
}

// WATER MASKS -----------------------------------------------------------------------------------

/**
 * Gets water pixels in a region and time-frame based on Sentinel-1 data
 */
exports.sentinelWaterMask = function(startUnixDays, endUnixDays, _geom) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));
  var image = filterOptionalBounds(ee.ImageCollection('COPERNICUS/S1_GRD'), _geom)
                .filterDate(startDate, endDate)
                .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
                .select('VV')
                .median();
  var waterMask = image.select('VV').lte(-19).selfMask();
  if (_geom) {
    return waterMask.clip(_geom);
  }
  return waterMask;
}

/** 
 * Gets a global mask where a value of 1 indicates ocean.
 * Ocean is considered to start a short distance away from the coast, in order to support historic coastline mapping.
 * Inland rivers and water bodies are also excluded.
 */
exports.oceanMask = function(_negate) {
  // Build land + coastline mosaic
  var mostLand = ee.ImageCollection('ESA/WorldCover/v100').mosaic().selfMask().rename('land');
  var greenland = ee.Image('OSU/GIMP/2000_ICE_OCEAN_MASK').select('ocean_mask').eq(0).selfMask().rename('land');
  var antarctica = ee.Image('CPOM/CryoSat2/ANTARCTICA_DEM').select('elevation').gt(-1000).selfMask().rename('land');
  var arctic = ee.Image('UMN/PGC/ArcticDEM/V3/2m_mosaic').select('elevation').gt(-1000).selfMask().rename('land');
  var allLand = ee.ImageCollection([mostLand, greenland, antarctica, arctic]).mosaic();
  if (_negate) {
    return allLand;
  }
  // Invert to return ocean only
  return allLand.unmask().not().selfMask().rename('ocean');
}

// DEFORESTATION EXPORT FUNCTIONS ----------------------------------------------------------------
// Hansen, RADD and GLAD

/**
 * Gets RADD deforestation alerts at global scale
 * Data available from Jan 2019 - see Images end and last modified dates at
 * https://code.earthengine.google.com/?asset=projects/radar-wur/raddalert/v1
 * 
 * @returns {ee.Image} with deforestation data for the time-period (unixDays) it was generated
 */
exports.get_radd_alerts = function(startUnixDays, endUnixDays, _geom) {
	var collection = ee.ImageCollection(exports.CONSTANTS.ALERTS_RADD)
		.filter(ee.Filter.stringContains('system:index','primary').not());

	var latest = filterOptionalBounds(collection, _geom).mosaic();
	if (_geom) {
    latest = latest.clip(_geom);
	}
	
	// Convert start and end to YYDOY (Year-Year-Day-Of-Year) so
	// they're compatible with latest.select('Date') band values
	var raddStart = unixDaysToYYDOY(startUnixDays);
	var raddEnd = unixDaysToYYDOY(endUnixDays);
	
	// Build mask where confidence level is met, and the deforestation Date is in range
  var mask = latest.select('Alert').eq(3)
                   .and(latest.select('Date').gte(raddStart))
                   .and(latest.select('Date').lte(raddEnd));

	return latest.updateMask(mask).select('Date');
}

/**
 * Gets vectorised RADD deforestation alerts.
 * Data available up to Oct 2021 - see Images end and last modified dates at
 * https://code.earthengine.google.com/?asset=projects/radar-wur/raddalert/v1
 * 
 * IMPORTANT: scale is fixed at 10m resolution based on source data.
 * At other resolutions, band 'Date' values get smoothed and we end up with invalid YYDOY values.
 * 
 * @returns {ee.FeatureCollection} with a max of one multi/polygon feature per day between start and end
 */
exports.get_radd_alerts_vect = function(startUnixDays, endUnixDays, geom, multiPolygonDateProperty) {
  var radd_img = exports.get_radd_alerts(startUnixDays, endUnixDays, geom);

  var proj = ee.Image(ee.ImageCollection(exports.CONSTANTS.ALERTS_RADD).first()).projection();
  // approx: ee.Projection('EPSG:4326', [0.00009, 0, -17, 0, -0.00009, 15.746748]);
  
  var vectors = radd_img.reduceToVectors({
    // reducer: ee.Reducer.countEvery(),
    geometry: geom,
    geometryType: 'polygon',
    eightConnected: true, // !!multiPolygonDateProperty, // combine diagonals only if we're not grouping later
    maxPixels: 1e11,
    labelProperty: 'Date',
    crs: proj,
    geometryInNativeProjection:false,
    // tileScale: 16, // help prevent 'user memory limit exceeded'
    // scale: 10 // per raster
  });
  
  if (multiPolygonDateProperty) {
    return groupFeatures(vectors, 'Date', multiPolygonDateProperty);
  }
  return vectors; // .map(calculateArea);
}

/**
 * Identifies GLAD (LANDSAT) deforestation alerts anywhere in the world
 *
 * @param {number | ee.Number} start - start date in days since Unix epoch
 * @param {number | ee.Number} end - end date in days since Unix epoch
 * @param {ee.Geometry} _geom - optional geometry used to filter relevant source images and clip results
 * @param {boolean} _forceFullDataset - optional flag whether to always include the full GLAD data catalog,
 * rather than attempt to filter relevant image collections based on start and end dates.
 * @returns {ee.Image} an Earth Engine image with a single band showing glad deforestation alerts
 */
exports.get_glad_alerts = function(start, end, _geom, _forceFullDataset) {
  // GLAD is a composite of multiple collections, historic yearly "final" images plus an ongoing updated collection for the current year
  var glad2017 = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2017), 2017, '17');
  var glad2018 = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2018), 2018, '18');
  var glad2019 = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2019), 2019, '19');
  var glad2020a = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2019), 2020, '20');
  var glad2020b = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2020), 2020, '20');
  var glad2021a = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.a2020), 2021, '21');
  var glad2021b = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.latest), 2021, '21');
  var glad2022a = cleanGLAD_year(ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.latest), 2022, '22');

  // We only need to use the full data set where requested, or start/end are server-side date calculations
  var useFullDataset = _forceFullDataset || typeof start !== 'number' || typeof end !== 'number';
  var gladArray = useFullDataset ? [glad2017, glad2018, glad2019, glad2020a, glad2020b, glad2021a, glad2021b, glad2022a] : [];
  
  // If we're not using the full dataset, include relevant GLAD alerts between dates from 2017-2022
  if (!useFullDataset && end >= exports.dateToUnixDays(2017)) {
    if (start < exports.dateToUnixDays(2018)) {
      gladArray.push(glad2017);
    }
    if (end >= exports.dateToUnixDays(2018) && start < exports.dateToUnixDays(2019)) {
      gladArray.push(glad2018);
    }
    if (end >= exports.dateToUnixDays(2019) && start < exports.dateToUnixDays(2020)) {
      gladArray.push(glad2019);
    }
    if (end >= exports.dateToUnixDays(2020) && start < exports.dateToUnixDays(2021)) {
      gladArray.push(glad2020a, glad2020b);
    }
    if (end >= exports.dateToUnixDays(2021) && start < exports.dateToUnixDays(2022)) {
      gladArray.push(glad2021a, glad2021b);
    }
    if (end >= exports.dateToUnixDays(2022)) {
      gladArray.push(glad2022a);
    }
  }

  // Filter out source images that are outside _geom (if provided) and get the 'alert-date' band
  var allAlerts = filterOptionalBounds(ee.ImageCollection(gladArray), _geom).cast({
    bandTypes: {
      'alert-date': 'int',
    },
    bandOrder: ['alert-date'],
  });
  
  // Filter to only include source image pixels with confirmed alerts in our date range
  allAlerts = allAlerts.map(function(img) {
    return img.updateMask(img.gte(start).and(img.lte(end)));
  });

  // We return the _max_ alert date for each pixel
  /*
     NOTE: This may mean pixels with earlier alerts get overwritten with later alert dates.
           These _should_ be edge cases - once deforested an area _usually_ stays deforested,
           but the problem can be quite noticeable with larger date ranges.
  */
  var maxAlerts = allAlerts.max();
  
  // Clip to geometry and return results
  if (_geom) {
    maxAlerts = maxAlerts.clip(_geom);
  }
  return maxAlerts;
}

/**
 * Identifies GLAD (LANDSAT) deforestation alerts as a vector (if a geometry is defined)
 * uses all glad image collections from 2017-2022
 * enter start and end date in unixdays
 *
 * @param {number | ee.Number} start - start date in days since Unix epoch
 * @param {number | ee.Number} end - end date in days since Unix epoch
 * @param {ee.Geometry} geom - geometry used to filter relevant source images and clip results
 * @param {string} _multiPolygonDateProperty - optional property name to return instead of 'alert-date'
 * @param {boolean} _forceFullDataset - optional flag whether to always include the latest GLAD data,
 * which may overwrite some historic deforestation alert pixels with their most recent alert dates.
 * This could be problematic when analysing historic start-end periods, depending on the application.
 * @returns {ee.FeatureCollection} a FeatureCollection containing alert polygons, each with an alert date property value in unix days
 */
exports.get_glad_alerts_vect = function(start, end, geom, _multiPolygonDateProperty, _forceFullDataset) {
  var alerts = exports.get_glad_alerts(start, end, geom, _forceFullDataset);

  var proj = ee.ImageCollection(exports.CONSTANTS.ALERTS_GLAD.latest).first().projection();
  // approx: ee.Projection('EPSG:4326', [0, 0, -17, 0, 0, 15.746748]);

  var vectors = alerts.reduceToVectors({
    geometryType: 'polygon',
    geometry: geom,
    maxPixels: 1e11,
    eightConnected: true, // !!multiPolygonDateProperty, // combine diagonals only if we're not grouping later
    labelProperty: 'alert-date',
    crs: proj,
    geometryInNativeProjection: false,
    // tileScale: 4, // help prevent 'user memory limit exceeded'
    // scale: 30 // per raster
  });

  if (_multiPolygonDateProperty) {
    return groupFeatures(vectors, 'alert-date', _multiPolygonDateProperty);
  }
  return vectors; // .map(calculateArea);
}

/**
 * Get Hansen deforestation alerts anywhere in the world for the specified year(s)
 * from https://developers.google.com/earth-engine/datasets/catalog/UMD_hansen_global_forest_change_2021_v1_9
 * 
 * @param {number} firstYear - the first year for which deforestation should be returned
 * @param {number} _lastYear - optional end of year range for which deforestation should be returned
 * @param {boolean} _includeMinorLosses - optionally include alerts over areas where there are more 'loss'=0 samples than 'loss'=1
 * @returns {ee.Image} An Earth Engine image with a single band showing deforestation
 */
exports.get_hansen_alerts = function(firstYear, _lastYear, _includeMinorLosses) {
	var hansen = ee.Image(exports.CONSTANTS.ALERTS_HANSEN);
	
  // NOTE: 'loss' is a bit 0 or 1 indicating forest loss during the study period, defined as a stand-replacement disturbance -
  // a change from a forest to non-forest state).year of gross forest cover loss during the study period, defined as a 
  // stand-replacement disturbance, or a change from a forest to non-forest state.

  // 'lossyear' is the year of gross forest cover loss during the study period, defined as a stand-replacement disturbance, or a change from a forest to non-forest state.
  // Encoded as either 0 (no loss) or else a value in the range 1–21, representing loss detected primarily in the year 2001–2021, respectively.
  
  // At lower resolutions / zoom levels, 'loss' and 'lossyear' appear to be *sampled*.
  // So we can say 'loss'=0 represents where less than half of trees have been lost under a pixel.
  // But 'lossyear' will just be the most frequent year of loss under that pixel, which is less useful for low res images.
  
  // Change 2-digit Hansen "lossyear" to full year after 2000
  var yearImage = hansen;
  if (!_includeMinorLosses) {
    // Mask where median 'loss' is sampled to be 1 rather than 0
    yearImage = yearImage.updateMask(hansen.select('loss'));
  }
  yearImage = yearImage.select('lossyear').add(2000);

  // Given a single year, just mask where the lossyear matches
	if (!_lastYear || _lastYear === firstYear) {
    return yearImage.mask(
      yearImage.eq(firstYear)
    );
	}
  // Given two years, mask where the lossyear is between them
	return yearImage.mask(
    yearImage.gte(firstYear).and(yearImage.lte(_lastYear))
  );
}

/**
 * DYNAMIC WORLD DEFORESTATION ALERTS
 * (work in progress)
 *
 * Based on differences in probability between dates.
 * If the difference is higher than 0.6 the deforestation alert will be highlighted.
 */
exports.get_dynamic_world_alerts = function (startUnixDays, endUnixDays) {
  var dwCol = ee.ImageCollection(exports.CONSTANTS.DYNAMIC_WORLD).select('trees');
  
  // To ensure we have enough coverage, mosaic a few years prior to the requested dates
  var dwCol_start = dwCol.filterDate(unixDaysToDate(startUnixDays - 1500), unixDaysToDate(startUnixDays)).mosaic();
  var dwCol_end = dwCol.filterDate(unixDaysToDate(endUnixDays - 1500), unixDaysToDate(endUnixDays)).mosaic();
  
  // Then we subtract the probabilities between both images.
  // A threshold will be set up to distinguish between deforestation and no change (e.g. difference in probabilities higher than 0.5 = deforestation)
  var deforestation = dwCol_end.subtract(dwCol_start);
  return deforestation.lte(-0.5).selfMask();
}

/**
 * Get deforestation over a period based on the yearly Hansen dataset, overlaid with
 * RADD and GLAD deforestation alerts where the period overlaps _part_ of a year.
 *
 * @param {number} startUnixDays - start of period in days since Unix epoch 1970
 * @param {number} endUnixDays - end of period in days since Unix epoch 1970
 * @param {boolean} _includeMinorLosses - optionally include alerts over areas where there are more 'loss'=0 samples than 'loss'=1
 * @returns {ee.Image} an Earth Engine image with a single band showing deforestation
 */
exports.get_deforestation_all = function(startUnixDays, endUnixDays, _includeMinorLosses) {
  if (typeof startUnixDays !== 'number') {
    throw new Error('get_deforestation_all() start and end parameters must be numbers');
  }
  var startDate = unixDaysToDate(startUnixDays);
  var startYear = +startDate.getUTCFullYear();
  var startJan1 = exports.dateToUnixDays(startYear);
  var endDate = unixDaysToDate(endUnixDays);
  var endYear = +endDate.getUTCFullYear();
  var endDec31 = exports.dateToUnixDays(endYear + 1) - 1;
  var image = ee.Image(0);
  /* Debugging:
    print('get_deforestation_all starting parameters', {
      startUnixDays: startUnixDays, 
      endUnixDays: endUnixDays,
      startDate: startDate,
      startYear: startYear,
      startJan1: startJan1,
      startDec31: exports.dateToUnixDays(startYear + 1) - 1,
      endDate: endDate,
      endYear: endYear,
      endDec31: endDec31,
    });
  */
  
  // Use RADD/GLAD for a partial startYear >= 2017
  var useRaddGladForStartYear = startYear >= 2017 && startUnixDays > startJan1;
  if (useRaddGladForStartYear) {
    var firstEnd = endYear === startYear ? endUnixDays : exports.dateToUnixDays(startYear + 1) - 1;
    // print('Including GLAD for ' + startDate.toISOString().substring(0, 10) + ' to ' + unixDaysToDate(firstEnd).toISOString().substring(0, 10));
    image = exports.get_glad_alerts(startUnixDays, firstEnd).selfMask().unmask();
    if (startYear >= 2019) {
      // print('Including RADD for ' + startDate.toISOString().substring(0, 10) + ' to ' + unixDaysToDate(firstEnd).toISOString().substring(0, 10));
      image = image.add(exports.get_radd_alerts(startUnixDays, firstEnd).unmask());
    }
    // Check if Hansen is available for the start year
    if (startYear < new Date().getUTCFullYear()) {
      // TODO: Once we're returning PercentConfidence, override with 100% where RADD+GLAD overlap with Hansen alerts for this year
    }
    // We can return now if endYear matches startYear
    if (endYear === startYear) {
      return image.gt(0).selfMask();
    }
  }
  
  // Add Hansen for each full year
  var hansenStartYear = useRaddGladForStartYear ? startYear + 1 : startYear;
  var hansenEndYear = endUnixDays >= endDec31 ? endYear : endYear - 1;
  // print('Including Hansen full year deforestation ' + hansenStartYear.toString() + '-' + hansenEndYear.toString());
  image = image.add(exports.get_hansen_alerts(hansenStartYear, hansenEndYear, _includeMinorLosses).unmask());
  
  // Add RADD and GLAD for remaining part-year
  if (endUnixDays < endDec31) {
    if (endYear >= 2017) {
      // print('Including GLAD for ' + endYear.toString() + '-01-01 to ' + endDate.toISOString().substring(0, 10));
      var lastStart = exports.dateToUnixDays(endYear);
      image = image.add(exports.get_glad_alerts(lastStart, endUnixDays).selfMask().unmask());
      if (endYear >= 2019) {
        // print('Including RADD for ' + endYear.toString() + '-01-01 to ' + endDate.toISOString().substring(0, 10));
        image = image.add(exports.get_radd_alerts(lastStart, endUnixDays).unmask());
      }
      // Check if Hansen is available for the end year
      if (endYear < new Date().getUTCFullYear()) {
        // TODO: Once we're returning PercentConfidence, override with 100% where RADD+GLAD overlap with Hansen alerts for this year
      }
    }
  }
  
  // Return resulting mask composite
  return image.gt(0).selfMask();
}

// REMAINING LAND COVER --------------------------------------------------------------------------

/**
 * Gets remaining forest for the stated period
 *
 * @param {number} at_date - unix days value
 * @param {boolean} _excludePeat - whether areas intersecting 2016 peatland mask should be excluded
 * @returns {ee.Image} An Earth Engine image with a single band showing remaining forest 
 */
exports.get_remaining_forest = function(at_date, _excludePeat) {
	var start = exports.dateToUnixDays(2016);
	var df = ee.Image(exports.get_deforestation_all(start, at_date));
	var rem = df.unmask().not().selfMask().rename('remaining_forest');
	if (_excludePeat) {
    return rem.updateMask(onlyForest2015()); // mask pure forest, minus peat
	}
  return rem.updateMask(exports.forestMask2015());
}

/**
 * Gets remaining peat for the stated period
 *
 * @param {number} at_date - unix days value
 * @param {boolean} _excludeForest - whether areas from the 2016 peatland mask that intersect forest should be excluded
 * @returns {ee.Image} An Earth Engine image with a single band showing remaining peat 
 */
exports.get_remaining_peat = function(at_date, _excludeForest) {
	var start = exports.dateToUnixDays(2016);
	var df = ee.Image(exports.get_deforestation_all(start, at_date));
	var rem = df.unmask().not().selfMask().rename('remaining_peat');
	if (_excludeForest) {
    return rem.updateMask(exports.onlyPeat2015()); // mask only showing pure peat
	}
  return rem.updateMask(exports.peatlandMask());
}

/**
 * Gets remaining peat-forest (overlapping areas) for the stated period
 *
 * @returns {ee.Image} An Earth Engine image with a single band showing remaining peat-forest (overlapping areas)
 */
exports.get_remaining_peat_forest = function(at_date) {
	var start = exports.dateToUnixDays(2016);
	var df = ee.Image(exports.get_deforestation_all(start, at_date));
	var rem = df.unmask().not().selfMask().rename('remaining_forest');
	return rem.updateMask(exports.peatForestIntersectionAtStartOf2016());
}


// VEGETATION HEIGHT -----------------------------------------------------------------------------

/**
 * Vegetation height (GEDI Data)
 */
exports.GEDI_data = function(startUnixDays, endUnixDays) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));
  
  var dataset = ee.ImageCollection(exports.CONSTANTS.VEGETATION_HEIGHT_GEDI)
                  .filterDate(startDate, endDate)
                  .map(qualityMask_GEDI)
                  .select('rh98');
                  
  return dataset.mosaic();
}  

// FIRE ALERTS -----------------------------------------------------------------------------------
// FIRMS and MODIS

/**
 * Gets an image of FIRMS burns at global 500m scale over a period (2000+)
 * https://developers.google.com/earth-engine/datasets/catalog/FIRMS
 *
 * @returns {ee.Image} An Earth Engine image with a single band showing burned areas
 */
exports.get_firms_alerts = function(startUnixDays, endUnixDays) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));
	
	var collection = ee.ImageCollection(exports.CONSTANTS.ALERTS_FIRMS)
                     .filterDate(startDate, endDate);
  
  var result = collection
	//.map(createTimeBand)
		.map(function(img) {
			return img.select('confidence').gte(50).selfMask();
		})
		.mosaic()
    .addBands(ee.Image(0).rename('confidence'))
    .selfMask()
    .select('confidence');

	return result;
}

/**
 * Gets FIRMS burn alert feature boundaries at global 500m scale over a period (2000+)
 * https://developers.google.com/earth-engine/datasets/catalog/FIRMS
 *
 * @returns {ee.FeatureCollection} a FeatureCollection containing alert polygons, each with an alert date property value in unix days
 */
exports.get_firms_alerts_vect = function(startUnixDays, endUnixDays, geom, multiPolygonDateProperty) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));
	
  var proj = ee.Image(ee.ImageCollection(exports.CONSTANTS.ALERTS_FIRMS).first()).projection();
  // aprox: ee.Projection('SR-ORG:6974', [926.625433055833, 0, -20015109.354, 0, -926.6254330549998, 10007554.677]);

	var collection = ee.ImageCollection(exports.CONSTANTS.ALERTS_FIRMS)
                     .filterDate(startDate, endDate)
                     .filterBounds(geom)
                     .map(createTimeBandFIRMS)
                     .map(function(img) {
                       return img.updateMask(img.select('confidence').gte(50));
                     });
  var image = collection.mosaic().select(['date']); // , 'confidence']);
	
	var vectors = image.reduceToVectors({
    // reducer: ee.Reducer.mode(), // for 'confidence' values
    geometry: geom,
    geometryType: 'polygon',
    eightConnected: true, // !!multiPolygonDateProperty, // combine diagonals only if we're not grouping later
    maxPixels: 1e11,
    labelProperty: 'date',
    crs: proj,
    geometryInNativeProjection:false,
    // tileScale: 2, // help prevent 'user memory limit exceeded'
    // scale: 500 // per raster
  });
  
  if (multiPolygonDateProperty) {
    return groupFeatures(vectors, 'date', multiPolygonDateProperty);
  }
  return vectors; // .map(calculateArea);
}


/**
 * Gets an image of MODIS monthly burn alerts at global 500m scale over a period (2000 to 2022-02?)
 * https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD64A1
 *
 * @returns {ee.Image} An Earth Engine image with a single band showing burned areas anywhere in Indonesia-Malaysia
 */
exports.get_MCD64A1_alerts = function(startUnixDays, endUnixDays) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));
	
	var result = ee.ImageCollection(exports.CONSTANTS.ALERTS_MODIS)
    .filterDate(startDate, endDate)
		.map(function(img){
				return img.select('BurnDate').neq(0).and(img.select('Uncertainty').lte(50)).selfMask();
		});
		
	result = result.mosaic().addBands(ee.Image(0).rename('BurnDate')).selfMask().select('BurnDate');
	return result;
}


/**
 * Gets MODIS monthly burn alert feature boundaries at global 500m scale over a period (2000 to 2022-02?)
 * https://developers.google.com/earth-engine/datasets/catalog/MODIS_006_MCD64A1
 *
 * @returns {ee.FeatureCollection} a FeatureCollection containing alert polygons, each with an alert date property value in unix days
 */
exports.get_MCD64A1_alerts_vect = function(startUnixDays, endUnixDays, geom, multiPolygonDateProperty) {
  var startDate = ee.Date(unixDaysToEpochMs(startUnixDays));
  var endDate = ee.Date(unixDaysToEpochMs(endUnixDays === startUnixDays ? +endUnixDays + 1 : endUnixDays));

  var proj = ee.Image(ee.ImageCollection(exports.CONSTANTS.ALERTS_MODIS).first()).projection();
  // approx:  ee.Projection('SR-ORG:6974', [463.312716528, 0, -20015109.354, 0, -463.312716527, 10007554.677]);

	var result = ee.ImageCollection(exports.CONSTANTS.ALERTS_MODIS)
                 .filterDate(startDate, endDate)
                 .map(createTimeBandMODIS)
                 .map(function(img){
                    var masking1 = img.updateMask(img.select('BurnDate').neq(0));
                    return masking1.updateMask(masking1.select('Uncertainty').lte(50));
                  });
  
	result = result.select(['date']); // , 'Uncertainty']);
	result = result.cast({
    bandTypes:{
      'date':'int',
      // 'Uncertainty':'int'
    },
    bandOrder:['date'] // , 'Uncertainty']
    });
	result = result.mosaic();
	
	var vectors = result.reduceToVectors({
    // reducer: ee.Reducer.mode(), // for 'Uncertainty'
    geometry: geom,
    geometryType: 'polygon',
    eightConnected: true, // !!multiPolygonDateProperty, // combine diagonals only if we're not grouping later
    maxPixels: 1e11,
    labelProperty: 'date',
    crs: proj,
    geometryInNativeProjection:false,
    // tileScale: 2, // help prevent 'user memory limit exceeded'
    // scale: 500 // per raster
  });
  
  if (multiPolygonDateProperty) {
    return groupFeatures(vectors, 'date', multiPolygonDateProperty);
  }
  return vectors; // .map(calculateArea);
}

// ISOCHRONS (SOURCING AREAS AT 4h travelling time)

/**
 * Returns an isochron representing potential travel distance from a point in a specified time.
 *
 * @example <caption>Getting 4 hour isochrons for a set of mills in a FeatureCollection</caption>
 * var mills = ee.FeatureCollection('projects/ngis-tracemark-core-dev/assets/Mills_universal').limit(5);
 * var isochrons4h = mills.map(function(feature) {
 *   return lib.getIsochron(feature, 4 * 60);
 * });
 * Map.addLayer(ee.Feature(isochrons4h.first()), {}, "4h isochron");
 *
 * @param {ee.Feature} origin - point of origin for travel
 * @param {number} travelMinutes - minutes of travel from origin
 * @returns {ee.Feature} polygon representing how far someone can travel from `origin` in `travelMinutes`.
 */
exports.getIsochron = function(origin, travelMinutes) {
  // Assume we can't travel further than 100km per hour
  var maxMetres = 100 * 1000 * travelMinutes / 60;
  var region = origin.buffer(maxMetres * 1.5, 1);
  var GFS = ee.Image(exports.CONSTANTS.FRICTION);
  var scale = GFS.projection().nominalScale();
  // Define image with point highlighted as a single pixel
  var image = ee.Image().byte().paint(origin, 1).selfMask()
                .copyProperties(origin, origin.propertyNames());
  var cost = GFS.select('friction').cumulativeCost(image, maxMetres);
  cost = cost.updateMask(cost.lte(+travelMinutes));
    
  var properties = image.propertyNames();
  var cost_img = ee.Image(cost.copyProperties(image, properties));
  var cost_binary = cost_img.gte(0);
  
  var vectorized_isoch = cost_binary
    .addBands(ee.Image(0).updateMask(cost_img))
    .reduceToVectors({
      geometry: region.geometry(),
      scale: scale,
      geometryType: 'polygon',
      eightConnected: true,
      reducer: ee.Reducer.mean(),
      maxPixels:1e13,
    });
  
  return vectorized_isoch.first();
}


// PUBIC HELPER FUNCTIONS ------------------------------------------------------------------------

/**
 * Get an array of distinct Image dates in an ImageCollection.
 * Used to get Sentinel scene dates.
 */
exports.get_image_collection_dates = function(collection) {
  return collection
    .map(function(image) {
      // eslint-disable-next-line unicorn/no-null
      return ee.Feature(null, {
        start: image.get('system:time_start'),
        end: image.get('system:time_end'),
        date_range: image.get('date_range'),
        cadence: image.get('cadence'),
      });
    })
    .distinct('start')
    .sort('start', false);
}

/**
 * Converts from a date to days since Unix epoch
 * 
 * @param {Date | number} dateOrNumber - value to convert as a Javascript date, 2/4 digit year, ms or days since Unix epoch
 * @param {number} _month - optional month of year, where January is 1
 * @param {number} _day - optional day of month
 * @returns {number} - days since Unix epoch 1970
 */
exports.dateToUnixDays = function(dateOrNumber, _month, _day) {
  // Test if can be converted to a number per https://stackoverflow.com/a/45011633/154170
  // eslint-disable-next-line unicorn/prefer-number-properties
  if (isNaN(dateOrNumber)) {
    throw new Error('dateToUnixDays(dateOrNumber) parameter is invalid');
  }

  // Given an actual Date, strip time info and coerce it to UTC
  if (dateOrNumber instanceof Date) {
    var msDate = Date.UTC(dateOrNumber.getUTCFullYear(), dateOrNumber.getUTCMonth(), dateOrNumber.getUTCDate());
    return msDate / exports.CONSTANTS.MS_PER_DAY;
  }
  
  // We now expect (typeof dateOrNumber === 'number')
  
  // Handle call of the format dateToUnixDays(year, month?, day?)
  if (dateOrNumber < 3000 && dateOrNumber === Math.floor(dateOrNumber)) {
    if (dateOrNumber < 1000) {
      dateOrNumber += 2000; // year is < 4 digits, so apply default millenium
    }
    var msEpoch = Date.UTC(dateOrNumber, _month ? _month - 1 : 0, _day || 1);
    return msEpoch / exports.CONSTANTS.MS_PER_DAY;
  } 
  
  // Given a number less than the milliseconds in a day, assume it's days since unix epoch directly
  if (dateOrNumber < exports.CONSTANTS.MS_PER_DAY) {
    return dateOrNumber;
  }

  // Else for more than the milliseconds in a day, assume it's the total ms since unix epoch
  return Math.floor(dateOrNumber / exports.CONSTANTS.MS_PER_DAY);
}

/**
 * Gets the World Mollweide projection coordinate reference system as well-known text.
 * Commonly used to measure areas close to a longitudinal meridian of interest.
 */
exports.getCrsWorldMollweide = function(_longitude) {
  var meridian = 0;
  if (typeof _longitude === 'number') {
    if (isNaN(_longitude) || Math.abs(_longitude) > 180) {
      throw new Error('getCrsWorldMollweide(_longitude) longitude is optional, but must be between -180 and 180 if provided');
    }
    meridian = _longitude;
  }
  return (
    'PROJCS["World_Mollweide", \
      GEOGCS["GCS_WGS_1984", \
        DATUM["WGS_1984", \
          SPHEROID["WGS_1984",6378137,298.257223563]], \
        PRIMEM["Greenwich",0], \
        UNIT["Degree",0.017453292519943295]], \
      PROJECTION["Mollweide"], \
      PARAMETER["False_Easting",0], \
      PARAMETER["False_Northing",0], \
      PARAMETER["Central_Meridian",' +
    meridian.toString() +
    '], \
      UNIT["Meter",1], \
      AUTHORITY["EPSG","54009"]]'
  );
}

// PRIVATE HELPER FUNCTIONS ----------------------------------------------------------------------

/**
 * Converts from days to milliseconds since Unix epoch 1970,
 * as used in ee.Image "system:time_start" metadata.
 * 
 * @param {number | ee.Number} unixDays - days since Unix epoch 1970
 * @returns {number | ee.Number} - milliseconds (number or ee.Number calculation) since Unix epoch
 */
function unixDaysToEpochMs(unixDays) {
  // If we're provided a number, we can convert on the spot
  if (typeof unixDays === 'number') {
    return unixDays * exports.CONSTANTS.MS_PER_DAY;
  }
	return ee.Number(unixDays).multiply(exports.CONSTANTS.MS_PER_DAY);
}

/**
 * Converts from days since Unix epoch 1970 to a date.
 * 
 * @param {number | ee.Number} unixDays - days since Unix epoch 1970
 * @returns {Date | ee.Date} - javascript Date or ee.Date calculation
 */
function unixDaysToDate(unixDays) {
  var ms = unixDaysToEpochMs(unixDays);
  if (typeof ms === 'number') {
    return new Date(ms);
  }
	return ee.Date(ms);
}

/**
 * From unixdays to YYDOY
 * Applied to RADD and GLAD
 */
function unixDaysToYYDOY(unixdays, _centuryStartYear) {
  // Assume YY means 20YY by default
  // eslint-disable-next-line unicorn/prefer-default-parameters
  _centuryStartYear = _centuryStartYear || 2000;
  // If we're provided a number, we can convert on the spot
  if (typeof unixdays === 'number') {
    var date = new Date(unixdays * exports.CONSTANTS.MS_PER_DAY);
    var year = date.getUTCFullYear();
    _centuryStartYear = Math.floor(year / 100) * 100;
    var startOfYear = new Date(Date.UTC(year, 0, 1));
    var dayOfYear = 1 + Math.floor((date.getTime() - startOfYear.getTime()) / exports.CONSTANTS.MS_PER_DAY);
    return (year - _centuryStartYear) * 1000 + dayOfYear;
  }
  // Otherwise define the conversion as a server-side calculation
	var d = ee.Number(unixdays).multiply(exports.CONSTANTS.MS_PER_DAY);
	var j = ee.Date(d).getRelative('day', 'year');
	var y = ee.Date(d).get('year');
	return (ee.Number(y.subtract(_centuryStartYear)).multiply(1000)).add(j);
}

/**
 * Transforms year and month in units per days.
 *
 * @returns {ee.Date} an EE date calculation
 */
function _Unixdays(year, month) {
	return ee.Date.fromYMD(year, month, 1).millis().divide(exports.CONSTANTS.MS_PER_DAY);
}

/**
 * Quality mask for GEDI (raster) data
 */
function qualityMask_GEDI(im) {
  return im.updateMask(im.select('quality_flag').eq(1))
      .updateMask(im.select('degrade_flag').eq(0));
}

/**
 * Sets an 'Area_ha' property on a feature
function calculateArea(feature) {
  return feature.set('Area_ha', feature.area(1).divide(10000));
}
 */

/**
 * helps combine different glad alert collections
 */
function cleanGLAD_year(gladCollection, year, yearShortStr) {
  var yr = ee.Number(year);
  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
  var confidenceBandName = 'conf' + yearShortStr;
  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
  var alertDateBandName = 'alertDate' + yearShortStr;
  var mos = gladCollection
    /* TODO: Filter on images that have the bands we want, rather than a hardcoded exclusion 
      .map(function(image) {
        var bands = image.bandNames();
        image.set('hasAlertBands', bands.indexOf(alertDateBandName) >= 0 && bands.indexOf(confidenceBandName) >= 0);
        return image;
      })
      .filter(ee.Filter.eq('hasAlertBands', true))
    */
    .filterMetadata("system:index", "not_equals", "FEobsDate") // present in the 2019final collection
    .select([confidenceBandName, alertDateBandName])
    .mosaic();
  var alerts = mos.updateMask(mos.select(confidenceBandName).eq(3));
  return alerts.select(alertDateBandName).selfMask().add(_Unixdays(yr,1)).rename('alert-date');
}

/**
 * Creates time band for MODIS alerts
 */
function createTimeBandMODIS(i) {
  var year = i.get('system:index')
  year = ee.String.encodeJSON(year);
  year = ee.String(year).slice(1,5);
  year = ee.Number.parse(year);
  var imgYear = ee.Image(year)
  imgYear = imgYear.multiply(1000);
  var burnDay = i.select('BurnDate');
  var yearDay = imgYear.add(burnDay)
  return i.addBands(yearDay.rename('date'))
}

/**
 * Creates time band for FIRMS alerts
 */
function createTimeBandFIRMS(i) {
  var addDateImage = ee.Image(i.metadata('system:time_start'));
  addDateImage = addDateImage.divide(exports.CONSTANTS.MS_PER_DAY).toInt();
  return i.addBands(addDateImage.rename('date'));
}

/**
 * Groups features by a property, unioning their geometries,
 * and optionally renaming the grouping property
 */
function groupFeatures(features, groupBy, _groupByAs) {
  /* NOTE: simple grouping per below results in "too many concurrent operations" error
    var groups = vectors
      .map(function(feature) {
        return ee.Feature(null, { Date: feature.get(groupBy) });
      })
      .distinct(groupBy);
      
    return groups.map(function(feature) {
      return ee.Feature(vectors.filter(ee.Filter.eq(groupBy, feature.get(groupBy))).geometry(), { group: feature.get(groupBy) });
    });
  */
  
  var reducerDict = features.reduceColumns(ee.Reducer.toList().group(), [groupBy, '.geo']);

  // Get the list of groups from the reducer's dictionary.
  var groupList = ee.List(reducerDict.get('groups'));
    
  // For each group, dissolve the geometries with union.
  var dissolvedAreas = groupList.map(function(groupObject) {
    // List.map doesn't know element types, so declare the type.
    var group = ee.Dictionary(groupObject);
    // Get this group's list of matches.
    var geometries = ee.List(group.get('list'));
    // Convert the list of geometries into a FeatureCollection.
    var features = ee.FeatureCollection(geometries.map(function(geo) {
      return ee.Feature(ee.Geometry(geo));
    }));
    // Compute the area of the union (which has one feature).
    var union = features.union(1).first();
    return union.set(_groupByAs || groupBy, group.get('group'));
  });
  return ee.FeatureCollection(dissolvedAreas);
}

/**
 * Calls collection.filterBounds(geom) only if geom is present
 */
function filterOptionalBounds(collection, _geom) {
  if (_geom) {
    return collection.filterBounds(_geom);
  }
  return collection;
}

